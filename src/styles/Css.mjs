// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Css from "@emotion/css";

function declaration(property, value) {
  return property + ": " + value + ";";
}

function breakpointSpecifity(breakpoint, rules) {
  return "." + breakpoint + "& {\n    " + rules + "\n}";
}

function toValue(type_) {
  if (type_ === "maxWidth") {
    return "max-width";
  } else {
    return "min-width";
  }
}

var BreakpointType = {
  toValue: toValue
};

function responsiveBreakpoint(breakpoint, css, type_Opt, param) {
  var type_ = type_Opt !== undefined ? type_Opt : "minWidth";
  return Css.css("\n      @media (" + toValue(type_) + ": " + String(breakpoint) + "px) {\n        " + css + "\n      }\n    ");
}

function minWidth(breakpoint, rules) {
  return Css.css("@media (min-width: " + String(breakpoint) + "px) {\n        " + rules + "\n      }");
}

function sm(styles) {
  return Css.css(minWidth(640, styles));
}

function active(rules) {
  return Css.css("&:active {\n  " + rules + "\n}");
}

function link(rules) {
  return Css.css("&:link {\n  " + rules + "\n}");
}

function visited(rules) {
  return Css.css("&:visited {\n  " + rules + "\n}");
}

function hover(rules) {
  return Css.css("&:hover {\n  " + rules + "\n}");
}

function toValue$1(value) {
  if (value === "initial") {
    return "initial";
  } else if (value === "spaceAround") {
    return "space-around";
  } else if (value === "stretch") {
    return "stretch";
  } else if (value === "end") {
    return "end";
  } else if (value === "start") {
    return "start";
  } else if (value === "center") {
    return "center";
  } else if (value === "revert") {
    return "revert";
  } else if (value === "baseline") {
    return "baseline";
  } else if (value === "spaceBetween") {
    return "space-between";
  } else if (value === "unset") {
    return "unset";
  } else if (value === "flexStart") {
    return "flex-start";
  } else if (value === "unsafeCenter") {
    return "unsafe center";
  } else if (value === "inherit") {
    return "inherit";
  } else if (value === "normal") {
    return "normal";
  } else if (value === "flexEnd") {
    return "flex-end";
  } else if (value === "safeCenter") {
    return "safe center";
  } else {
    return "space-evenly";
  }
}

var AlignContent = {
  toValue: toValue$1
};

function toValue$2(value) {
  if (value === "end") {
    return "end";
  } else if (value === "start") {
    return "start";
  } else if (value === "center") {
    return "center";
  } else if (value === "baseline") {
    return "baseline";
  } else if (value === "flexStart") {
    return "flex-start";
  } else if (value === "unsafeCenter") {
    return "unsafe center";
  } else if (value === "normal") {
    return "normal";
  } else if (value === "flexEnd") {
    return "flex-end";
  } else if (value === "safeCenter") {
    return "safe center";
  } else {
    return "stretch";
  }
}

var AlignItems = {
  toValue: toValue$2
};

function toValue$3(value) {
  if (value === "end") {
    return "end";
  } else if (value === "selfEnd") {
    return "self-end";
  } else if (value === "start") {
    return "start";
  } else if (value === "center") {
    return "center";
  } else if (value === "baseline") {
    return "baseline";
  } else if (value === "flexStart") {
    return "flex-start";
  } else if (value === "unsafeCenter") {
    return "unsafe center";
  } else if (value === "normal") {
    return "normal";
  } else if (value === "flexEnd") {
    return "flex-end";
  } else if (value === "safeCenter") {
    return "safe center";
  } else if (value === "selfStart") {
    return "self-start";
  } else {
    return "stretch";
  }
}

var AlignSelf = {
  toValue: toValue$3
};

function toValue$4(val) {
  if (val === "revert") {
    return "revert";
  } else if (val === "unset") {
    return "unset";
  } else if (val === "inherit") {
    return "inherit";
  } else {
    return "initial";
  }
}

var All = {
  toValue: toValue$4
};

function toAngle(angle) {
  var variant = angle.NAME;
  if (variant === "turn") {
    return String(angle.VAL) + "turn";
  } else if (variant === "deg") {
    return String(angle.VAL) + "deg";
  } else if (variant === "rad") {
    return String(angle.VAL) + "rad";
  } else {
    return String(angle.VAL) + "grad";
  }
}

var Angle = {
  toAngle: toAngle
};

function toValue$5(val) {
  if (val.NAME === "ms") {
    return String(val.VAL / 1000) + "s";
  } else {
    return String(val.VAL) + "s";
  }
}

var AnimationDelay = {
  toValue: toValue$5
};

function renderMultipleValues(values) {
  return values.join(", ");
}

function toValue$6(val) {
  if (val === "alternateReverse") {
    return "alternate-reverse";
  } else if (val === "normal") {
    return "normal";
  } else if (val === "alternate") {
    return "alternate";
  } else {
    return "reverse";
  }
}

function toManyValues(values) {
  return values.map(toValue$6).join(", ");
}

var AnimationDirection = {
  toValue: toValue$6,
  toManyValues: toManyValues
};

function toValue$7(value) {
  if (value.NAME === "ms") {
    return String(value.VAL / 1000) + "s";
  } else {
    return String(value.VAL) + "s";
  }
}

var AnimationDuration = {
  toValue: toValue$7
};

function toValue$8(value) {
  if (value === "none") {
    return "none";
  } else if (value === "backwards") {
    return "backwards";
  } else if (value === "forwards") {
    return "forwards";
  } else {
    return "both";
  }
}

function toManyValues$1(values) {
  return values.map(toValue$8).join(", ");
}

var AnimationFillMode = {
  toValue: toValue$8,
  toManyValues: toManyValues$1
};

function toValue$9(value) {
  if (typeof value === "object") {
    return String(value.VAL);
  } else {
    return "infinite";
  }
}

function toManyValues$2(values) {
  return values.map(toValue$9).join(", ");
}

var AnimationIterationCount = {
  toValue: toValue$9,
  toManyValues: toManyValues$2
};

function toValue$10(value) {
  if (typeof value === "object") {
    return value.VAL;
  } else {
    return "none";
  }
}

function toManyValues$3(values) {
  return values.map(toValue$10).join(", ");
}

var AnimationName = {
  toValue: toValue$10,
  toManyValues: toManyValues$3
};

function toValue$11(value) {
  if (value === "paused") {
    return "paused";
  } else {
    return "running";
  }
}

function toManyValues$4(values) {
  return values.map(toValue$11).join(", ");
}

var AnimationPlayState = {
  toValue: toValue$11,
  toManyValues: toManyValues$4
};

function toValue$12(val) {
  if (typeof val === "object") {
    return String(val.VAL);
  } else if (val === "jumpNone") {
    return "jump-none";
  } else if (val === "end") {
    return "end";
  } else if (val === "start") {
    return "start";
  } else if (val === "jumpEnd") {
    return "jump-end";
  } else if (val === "jumpStart") {
    return "jump-start";
  } else {
    return "jump-both";
  }
}

var Steps = {
  toValue: toValue$12
};

function toValue$13(value) {
  if (typeof value !== "object") {
    if (value === "easeInOut") {
      return "ease-in-out";
    } else if (value === "linear") {
      return "linear";
    } else if (value === "stepStart") {
      return "steps(1, start)";
    } else if (value === "stepEnd") {
      return "steps(1)";
    } else if (value === "easeIn") {
      return "ease-in";
    } else if (value === "easeOut") {
      return "ease-out";
    } else {
      return "ease";
    }
  }
  if (value.NAME === "steps") {
    var match = value.VAL;
    var v2 = match[1];
    var v1 = match[0];
    if (v2 === "jumpEnd" || v2 === "end") {
      return "steps(" + toValue$12(v1) + ")";
    } else {
      return "steps(" + toValue$12(v1) + ", " + toValue$12(v2) + ")";
    }
  }
  var match$1 = value.VAL;
  return "cubic-bezier(" + String(match$1[0]) + ", " + String(match$1[1]) + ", " + String(match$1[2]) + ", " + String(match$1[3]) + ")";
}

var AnimationTimingFunction = {
  Steps: Steps,
  toValue: toValue$13
};

function toValue$14(color) {
  return "#" + color.VAL;
}

var Color = {
  toValue: toValue$14
};

function toValue$15(color) {
  return "#" + color.VAL;
}

var Background = {
  toValue: toValue$15
};

function alignContent(value) {
  return Css.css(declaration("align-content", toValue$1(value)));
}

function alignContentRaw(value) {
  return declaration("align-content", toValue$1(value));
}

function alignItems(value) {
  return Css.css(declaration("align-items", toValue$2(value)));
}

function alignSelf(value) {
  return Css.css(declaration("align-items", toValue$3(value)));
}

function all(value) {
  return Css.css(declaration("all", toValue$4(value)));
}

function animationDelay(value) {
  return Css.css(declaration("animation-delay", toValue$5(value)));
}

function animationDirection(value) {
  return Css.css(declaration("animation-direction", toValue$6(value)));
}

function animationDirectionMany(values) {
  return Css.css(declaration("animation-direction", toManyValues(values)));
}

function animationDuration(value) {
  return Css.css(declaration("animation-duration", toValue$7(value)));
}

function animationFillMode(value) {
  return Css.css(declaration("animation-fill-mode", toValue$8(value)));
}

function animationFillModeMany(values) {
  return Css.css(declaration("animation-fill-mode", toManyValues$1(values)));
}

function animationIterationCount(value) {
  return Css.css(declaration("animation-iteration-count", toValue$9(value)));
}

function animationIterationCountMany(values) {
  return Css.css(declaration("animation-iteration-count", toManyValues$2(values)));
}

function animationName(value) {
  return Css.css(declaration("animation-name", toValue$10(value)));
}

function animationNameMany(values) {
  return Css.css(declaration("animation-name", toManyValues$3(values)));
}

function animationPlayState(value) {
  return Css.css(declaration("animation-play-state", toValue$11(value)));
}

function animationPlayStateMany(values) {
  return Css.css(declaration("animation-play-state", toManyValues$4(values)));
}

function animationTimingFunction(value) {
  return Css.css(declaration("animation-timing-function", toValue$13(value)));
}

function background(hex) {
  return Css.css(declaration("background", toValue$14({
                      NAME: "hex",
                      VAL: hex
                    })));
}

function color(hex) {
  return Css.css(declaration("color", toValue$14({
                      NAME: "hex",
                      VAL: hex
                    })));
}

function colorRaw(hex) {
  return declaration("color", toValue$14({
                  NAME: "hex",
                  VAL: hex
                }));
}

export {
  declaration ,
  breakpointSpecifity ,
  BreakpointType ,
  responsiveBreakpoint ,
  minWidth ,
  sm ,
  active ,
  link ,
  visited ,
  hover ,
  AlignContent ,
  AlignItems ,
  AlignSelf ,
  All ,
  Angle ,
  AnimationDelay ,
  renderMultipleValues ,
  AnimationDirection ,
  AnimationDuration ,
  AnimationFillMode ,
  AnimationIterationCount ,
  AnimationName ,
  AnimationPlayState ,
  AnimationTimingFunction ,
  Color ,
  Background ,
  alignContent ,
  alignContentRaw ,
  alignItems ,
  alignSelf ,
  all ,
  animationDelay ,
  animationDirection ,
  animationDirectionMany ,
  animationDuration ,
  animationFillMode ,
  animationFillModeMany ,
  animationIterationCount ,
  animationIterationCountMany ,
  animationName ,
  animationNameMany ,
  animationPlayState ,
  animationPlayStateMany ,
  animationTimingFunction ,
  background ,
  color ,
  colorRaw ,
  
}
/* @emotion/css Not a pure module */
