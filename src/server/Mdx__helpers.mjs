// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fs from "fs";
import * as Path from "path";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Caml_format from "rescript/lib/es6/caml_format.js";
import GrayMatter from "gray-matter";
import * as Caml_splice_call from "rescript/lib/es6/caml_splice_call.js";
import * as NodeJS$RescriptMonorepo from "../bindings/NodeJS.mjs";
import * as SiteMetadata$RescriptMonorepo from "../data/SiteMetadata.mjs";

function toValue(val) {
  if (val === "authors") {
    return "authors";
  } else {
    return "blog";
  }
}

var DataType = {
  toValue: toValue
};

function toValue$1(frontmatterRawData, slug, type_, root, param) {
  var mdxPath = Path.join(root, "data", toValue(type_), slug + ".mdx");
  var mdPath = Path.join(root, "data", toValue(type_), slug + ".md");
  if (Fs.existsSync(mdxPath)) {
    NodeJS$RescriptMonorepo.Fs.readFileSync(undefined, undefined, mdxPath);
  } else {
    NodeJS$RescriptMonorepo.Fs.readFileSync(undefined, undefined, mdPath);
  }
  var fileName = Fs.existsSync(mdxPath) ? slug + ".mdx" : slug + ".md";
  var string = frontmatterRawData.lastmod;
  var lastmod = (string == null) ? "" : string;
  var bool = frontmatterRawData.draft;
  var isDraft = (bool == null) ? true : bool;
  var string$1 = frontmatterRawData.summary;
  var summary = (string$1 == null) ? "" : string$1;
  var array = frontmatterRawData.images;
  var images = (array == null) ? [] : array;
  var array$1 = frontmatterRawData.authors;
  var authors = (array$1 == null) ? [] : array$1;
  var str = frontmatterRawData.layout;
  var layout = (str == null) ? "" : str;
  return {
          title: frontmatterRawData.title,
          date: frontmatterRawData.date,
          tags: frontmatterRawData.tags,
          lastmod: lastmod,
          draft: isDraft,
          summary: summary,
          images: images,
          authors: authors,
          layout: layout,
          readingTime: "5m",
          slug: toValue(type_) + slug,
          fileName: fileName
        };
}

var FrontMatterFull = {
  toValue: toValue$1
};

var root = process.cwd();

function join(prim) {
  return Caml_splice_call.spliceApply(Path.join, [prim]);
}

var readFileSync = NodeJS$RescriptMonorepo.Fs.readFileSync;

function postFilePaths($$location) {
  return Belt_Array.keep(NodeJS$RescriptMonorepo.Fs.readdirSync(undefined, undefined, Path.join(root, "data", $$location)), (function (path) {
                return /\.mdx?$/.test(path);
              }));
}

function prependPathSegment($$location, pathSegment) {
  return Path.join($$location, pathSegment);
}

function readdirPreserveRelativePath($$location) {
  return Belt_Array.map(NodeJS$RescriptMonorepo.Fs.readdirSync(undefined, undefined, $$location), (function (pathSegment) {
                return Path.join($$location, pathSegment);
              }));
}

function readdirRecursive($$location) {
  return Belt_Array.reduce(readdirPreserveRelativePath($$location), [], (function (result, currentValue) {
                if (NodeJS$RescriptMonorepo.Fs.statSync(undefined, undefined, currentValue).isDirectory()) {
                  return Belt_Array.concat(result, readdirRecursive(currentValue));
                } else {
                  return Belt_Array.concat([currentValue], result);
                }
              }));
}

function removeMdxExtension(slug) {
  return slug.replace(/\.(mdx|md)?$/, "");
}

function toFileTypeValue(extension) {
  if (extension === "mdx") {
    return "mdx";
  } else {
    return "md";
  }
}

function getFileBySlug(rootOpt, slug) {
  var root$1 = rootOpt !== undefined ? rootOpt : root;
  var mdxPath = Path.join(root$1, "data", slug.join("/") + ".mdx");
  var mdPath = Path.join(root$1, "data", slug.join("/") + ".md");
  if (Fs.existsSync(mdxPath)) {
    return NodeJS$RescriptMonorepo.Fs.readFileSync(undefined, undefined, mdxPath);
  } else {
    return NodeJS$RescriptMonorepo.Fs.readFileSync(undefined, undefined, mdPath);
  }
}

function removeRoot(rootOpt, string) {
  var root$1 = rootOpt !== undefined ? rootOpt : root;
  return string.replace(Path.join(root$1, "/data", "blog"), "");
}

function getFiles(rootOpt, $$location) {
  var root$1 = rootOpt !== undefined ? rootOpt : root;
  var prefixPaths = Path.join(root$1, "data", $$location);
  var files = readdirRecursive(prefixPaths);
  return files.map(function (file) {
              return removeMdxExtension(removeRoot(undefined, file));
            });
}

function sortDesc(a, b) {
  var resultA = a.split("-");
  var resultB = b.split("-");
  var yearA = Caml_format.caml_int_of_string(Caml_array.get(resultA, 0));
  var monthA = Caml_format.caml_int_of_string(Caml_array.get(resultA, 1));
  var dayA = Caml_format.caml_int_of_string(Caml_array.get(resultA, 2));
  var yearB = Caml_format.caml_int_of_string(Caml_array.get(resultB, 0));
  var monthB = Caml_format.caml_int_of_string(Caml_array.get(resultB, 1));
  var dayB = Caml_format.caml_int_of_string(Caml_array.get(resultB, 2));
  if (yearA > yearB) {
    return -1;
  } else if (yearA === yearB) {
    if (monthA > monthB) {
      return -1;
    } else if (monthA === monthB) {
      if (dayA > dayB) {
        return -1;
      } else if (dayA === dayB) {
        return 0;
      } else {
        return 1;
      }
    } else {
      return 1;
    }
  } else {
    return 1;
  }
}

function getAllFrontMatter(blogPath) {
  var files = readdirRecursive(blogPath);
  var allFrontmatter = files.reduce((function (acc, file) {
          var fileName = file.replace(/\\/g, "/");
          var source = readFileSync(undefined, undefined, fileName);
          var slug = removeMdxExtension(removeRoot(undefined, fileName));
          var match = GrayMatter(source);
          var frontmatterFull = toValue$1(match.data, slug, "blog", process.cwd(), undefined);
          return acc.concat([frontmatterFull]);
        }), []);
  return allFrontmatter.sort(function (frontmatter1, frontmatter2) {
              return sortDesc(frontmatter1.date, frontmatter2.date);
            });
}

function getBlogPostsFromLatest(cwdOpt, pathOpt, param) {
  var cwd = cwdOpt !== undefined ? cwdOpt : root;
  var path = pathOpt !== undefined ? pathOpt : [
      "data",
      "blog"
    ];
  var buildPath = Caml_splice_call.spliceApply(Path.join, [[cwd].concat(path)]);
  var frontmatterArray = getAllFrontMatter(buildPath);
  return frontmatterArray.sort(function (a, b) {
              return sortDesc(a.date, b.date);
            });
}

var Params = {};

function returnSiteMetadata(pathOpt, param) {
  var path = pathOpt !== undefined ? pathOpt : [
      "data",
      "siteMetadata.json"
    ];
  var metadataPath = Caml_splice_call.spliceApply(Path.join, [[root].concat(path)]);
  return JSON.parse(NodeJS$RescriptMonorepo.Fs.readFileSync(undefined, undefined, metadataPath));
}

function kebabCase(str) {
  var matches = str.match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g);
  if (matches !== null) {
    return matches.map(function (x) {
                  return x.toLocaleLowerCase();
                }).join("-");
  } else {
    return "";
  }
}

function formatDateString(date) {
  return new Date(date).toLocaleDateString(SiteMetadata$RescriptMonorepo.metadata.locale, {
              year: "numeric",
              month: "long",
              day: "numeric"
            });
}

function createTagsDictionary(rootOpt, type_Opt, folder) {
  var root$1 = rootOpt !== undefined ? rootOpt : root;
  var type_ = type_Opt !== undefined ? type_Opt : "blog";
  var paths = getFiles(undefined, folder);
  var postFilePaths = paths.map(function (path) {
        var mdxPath = Path.join(root$1, "data", toValue(type_), path + ".mdx");
        var fileName = Fs.existsSync(mdxPath) ? path + ".mdx" : path + ".md";
        return Path.join(root$1, "data", folder, fileName);
      });
  var tagsMatrix = postFilePaths.map(function (postFilePath) {
        var source = readFileSync(undefined, undefined, postFilePath);
        return GrayMatter(source).data;
      });
  var buildDict = function (dictAcc, data) {
    var bool = data.draft;
    var isDraft = (bool == null) ? true : bool;
    if (data.tags.length > 0 && isDraft !== true) {
      data.tags.forEach(function (tag) {
            var formattedTag = kebabCase(tag);
            var value = Js_dict.get(dictAcc, formattedTag);
            if (value !== undefined) {
              dictAcc[formattedTag] = value + 1 | 0;
            } else {
              dictAcc[formattedTag] = 1;
            }
            
          });
    }
    return dictAcc;
  };
  return tagsMatrix.reduce(buildDict, {});
}

export {
  DataType ,
  FrontMatterFull ,
  root ,
  join ,
  readFileSync ,
  postFilePaths ,
  prependPathSegment ,
  readdirPreserveRelativePath ,
  readdirRecursive ,
  removeMdxExtension ,
  toFileTypeValue ,
  getFileBySlug ,
  removeRoot ,
  getFiles ,
  sortDesc ,
  getAllFrontMatter ,
  getBlogPostsFromLatest ,
  Params ,
  returnSiteMetadata ,
  kebabCase ,
  formatDateString ,
  createTagsDictionary ,
  
}
/* root Not a pure module */
